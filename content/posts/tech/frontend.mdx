---
date: 2022-08-10
title: FrontEnd
slug: /tech/frontend
tags: [tech]
---
## 웹바이탈!
코어 웹바이탈

### 소프트웨어 아키텍셔 경험

## 기술문답
### 이유들
#### 쿠키를 사용하는 이유
HTTP 프로토콜의 특성이자 약점을 보완하기 위해서 쿠키 또는 세션을 사용합니다.

기본적으로 HTTP 프로토콜 환경은 "connectionless, stateless"한 특성을 가지기 때문에 서버는 클라이언트가 누구인지 매번 확인해야합니다. 이 특성을 보완하기 위해서 쿠키와 세션을 사용.
- connectionless: 클라이언트가 요청을 한 후 응답을 받으면 그 연결을 끊어 버리는 특징
- stateless: 연결을 끊는 순간 클라이언트와 서버의 통신이 끝나며 상태 정보는 유지하지 않는 특성이 있다.

#### CDN 을 사용하는 이유는?
다음과 같은 장점이 있습니다.

1 . 서버의 과부하를 막는다.
2 . 물리적거리로 인한 속도저하를 막는다.
3 . 보안상의 이점

edge들은 컨텐츠를 전송하는데 특화된 서버로 내 서버 에서 제공하고자 하는 컨텐츠(웹페이지, 이미지, 영상등)들을 각국의 edge에 캐싱(저장)해서 요청이 일어난 지역의 응답을 edge가 대신하도록 함.

그러면 내 서버로 몰릴 트래픽이 각 edge로 분산되서 내 서버의 과부하를 막을 수 있게 됨.

#### SSR & CSR 고려해야하는 점
- 

### https

#### http
웹 서버와 유저 에이전트가 데이터를 송수신하기 위한 통신 프로토콜

### css 
#### flex
```css
```


#### animation
```css
```
#### 웹 접근성 방안

- 의미있는 이미지 대체 텍스트 적용(포지셔닝 기법)
- 키보드로 엘리먼트 접근이 가능할 수 있도록 tabIndex 정의(키보드 접근)
- 텍스트 콘텐츠 명도 대비는 3:1

### js 

#### Promise

```js
function sleep(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

await new Promise(r => setTimeout(r, 2000));

const sleep = ms => new Promise(r => setTimeout(r, ms));

await sleep(<duration>);
```


비동기 호출이 성공한 경우에만 순서대로 객체 만들기

```js
function request(ms, value) {
  if(!ms) {
     return new Promise((resolve, reject) => {
      throw Error('Error');
    });
  } else{
    return new Promise(resolve => setTimeout(()=>{
      resolve(`result.. ${value}`)
    }, ms));
  }
}

const requestrObj = {'A': 5000, 'B': null, 'C': 100}

// 순서에 상관없는 응답을 원한다면 
const x = await Promise.all(
  Object.entries(requestrObj).map(async ([key, ms]) => {
    try{
      const data = await request(ms, key)
      return data
    } catch{
    }
  }),
)

console.log(x)

// 순서가 보장되는 map 활용 
const map = new Map()

// for문에서 비동기 제어: for await of와 비슷한 방식으로 for of 또는 for in
for(let [key, ms] of Object.entries(requestrObj)){
  try{
    const data = await request(ms, key)
    map.set(key, data) 
  } catch (err){
    console.log(err)
  }
}

console.log(map)

```


#### 자바스크립트 배열은 배열이 아니다?

일반적으로 배열은 동일한 크기의 메모리에 연속적인 공간을 갖는다. 이를 밀집 배열(dense array)이라 한다. 그러나 자바스크립트의 배열은 요소 각각의 메모리 공간은 동일한 크기를 갖지 않아도 되며 연속적으로 이어져 있지 않을 수도 있다. 배열의 요소가 연속적으로 이어져 있지 않는 배열을 희소 배열(sparse array)이라 한다.

이처럼 자바스크립트의 배열은 엄밀히 말해 일반적 의미의 배열이 아니다. 자바스크립트의 배열은 일반적인 배열의 동작을 흉내낸 특수한 객체이다. 인덱스를 프로퍼티 키로 갖으며 length 프로퍼티를 갖는 특수한 객체이다. 자바스크립트 배열의 요소는 사실 프로퍼티 값이다. 자바스크립트에서 사용할 수 있는 모든 값은 객체의 프로퍼티 값이 될 수 있으므로 어떤 타입의 값이라도 배열의 요소가 될 수 있다.

```js
console.log(Object.getOwnPropertyDescriptors([1, 2, 3]));
/*
{
  '0': { value: 1, writable: true, enumerable: true, configurable: true },
  '1': { value: 2, writable: true, enumerable: true, configurable: true },
  '2': { value: 3, writable: true, enumerable: true, configurable: true },
  length: { value: 3, writable: true, enumerable: false, configurable: false }
}
*/
```

일반적인 배열은 인덱스로 배열 요소에 빠르게 접근할 수 있다. 하지만 특정 요소를 탐색하거나 요소를 삽입 또는 삭제하는 경우에는 효율적이지 않다.
자바스크립트 배열은 해시 테이블로 구현된 객체이므로 인덱스로 배열 요소에 접근하는 경우, 일반적인 배열보다 성능적인 면에서 느릴 수 밖에 없는 구조적인 단점을 갖는다. 하지만 특정 요소를 탐색하거나 요소를 삽입 또는 삭제하는 경우에는 일반적인 배열보다 빠른 성능을 기대할 수 있다.

#### Set과 Array

- Array: 연속적인 메모리에 할당된 데이터 유형(중복가능)
- Set: 순서적으로 할당될 필요 없이 중복없는 요소 또는 객체들이 포함된 추상적인 데이터 유형(중복불가)

참고) Set은 iterable한 객체만 인자로 받는다.


```js
const source = [1,2,3,2]
const set = new Set(source); // {1,2,3}
const arr = Array.from(set);// [1,2,3]

console.log(set[0]); //undefined
console.log(arr[0]); //1

console.log(set.has(0)); // false
console.log(set.has(1)); //true

console.log(arr.indexOf(0)); // -1
console.log(arr.indexOf(1)); //0
console.log(arr.includes(0)); // false
console.log(arr.includes(1)); // true

const setObj = new Set(); // Create a New Set.

setObj.add({x: 10, y: 20}); // Add object in the set.
setObj.add({x: 20, y: 30}); // Add object in the set.

// Delete any point with `x > 10`.
setObj.forEach(function(point){
  if(point.x > 10){
    setObj.delete(point)
  }
})


```

중복된 키를 제외한 나머지를 구해보자! 

```js
const arr = ['A', 'B', 'C', 'B', 'C', 'D'];
const arrUnique = arr.filter((value, index) => {
  // lastIndexOf 체크 안하면 중복만 제거되어 리턴
  return arr.indexOf(value) === index && arr.lastIndexOf(value) === index;
});
console.log(arrUnique); // ['A', 'D']

```

#### Map과 Object의 차이

- key 필드: Map에서는 모든 데이터유형이 가능하며 순서가 보장된다. Obejct는 단순유형만 가능하며 순서가 보장되지 않는다.
- 요소 순서: Map에서는, 원래의 요소들의 순서가 보존되지만 Object는 그렇지 않다.

참고) 
Map은 iterable한 객체만 인자(ex. [[ 1, 'one' ],[ 2, 'two' ]])로 받는다. 또 Map키의 경우 SameValueZero(-0, 0, +0 동일)알고리즘에 따라 key를 갖는다. 따라서 값에 의한 호출은 동등성을 가지고 참조에 의한 호출은 별도의 키가 된다.


```js
const map = new Map()
map.set('A', 'B')
map.has('A') // true
map.get('A') // B

map.set({test:'test'}, 'test')
map.has({test:'test'}) // false
map.get({test:'test'}) // undefined

const key = {key:'key'}
map.set(key, 'key')
map.has(key) // true
map.get(key) // test

console.log(map.size) // 3
console.log([...map.values()]) // ['B', 'test', 'key']
```


정리, 단순구조인 경우 Object 가 빠르고 delete 작업시에는 Map의 성능이 더 좋다. 반복이나 요소의 순서가 중요한 경우에도 Map이 더 좋다.

----
- https://poiemaweb.com/js-array-is-not-arrray
- https://medium.com/front-end-weekly/es6-set-vs-array-what-and-when-efc055655e1a
- https://medium.com/front-end-weekly/es6-map-vs-object-what-and-when-b80621932373