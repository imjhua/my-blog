---
title: Issue
slug: /resume/issue
date: 2022-08-07
---

## 401 인증 에러
슈퍼앱내 개별 서비스들 가입여부를 확인하는 API에서도 미가입자의 경우 401에러코드를 반환하는데, 이는 웹뷰의 인증토큰을 확인할때도 사용되는 에러코드로 공통 에러처리가 되어있어 에러페이지가 노출되는 문제가 있음.
- 에러처리는 '유효하지 않은 사용자입니다. 인증해주세요.' 안내문구노출
- 동일한 401에러이지만 구분이 필요했다. 인증을 확인하는 코드에서 인증에러(InvalidAccessTokenError, RequiredAccessTokenError)에 대한 별도 에러객체를 정의함.
- 공통에러핸들러쪽에서 해당 에러에 대해서만 인증에러 처리를 하도록 함.


export class InvalidAccessTokenError extends GenericCarnerError {
  constructor() {
    super('AccessToken값이 유효하지 않습니다.', 401)
    this.name = 'InvalidAccessTokenError'
  }
}
export class RequiredAccessTokenError extends GenericCarnerError {
  constructor() {
    super('AccessToken값을 필요로 합니다.', 401)
    this.name = 'RequiredAccessTokenError'
  }
}



## 웹뷰내 스타일 미적용이슈 
내비앱과 티앱, 두가지 애플리케이션에서 제공되는 웹뷰서비스내 스타일에 문제가 있다.
- 각각의 호환성 버전이 달랐기에 함께 고려되어야 했다.
- 지원되는 css를 확인하고 적용하는 습관을 가지게되었다.
- Android: 6 (SDK API Level 23) / IOS: 13.4

## 웹뷰 인증이슈
내비앱과 티앱, 두가지 애플리케이션에서 제공되는 웹뷰서비스내 인증에 문제가 있다.
- 각각의 인증방식이 달랐다. 하나는 헤더에 인증토큰 / 다른 하나는 쿠키인증
- 인증방식을 통일하여 웹뷰에서 발생하는 인증문제를 해결하였다.

## 가로모드 대응 범위 논의 
프로모션 페이지 작업으로 모바일, 테블릿에서의 해상도별 디자인 및 작업량 확인이 필요한데, 앱별, 운영체제별 가로모드 지원 범위가 달랐다.
- 안드/IOS 앱별, 특정화면 가로모드 지원범위를 확인하고 관련 담당자들(클라개발자,기획,디자인)과 가로모드 지원 범위를 확정할 수 있는 논의 진행
- 페이지내 이동가능한 웹뷰들을 나열하여 전체 플로우를 디자인과 확인 후 반응형을 지원하도록 하였다.
- 모바일 사이즈 320(360), 태블릿 640(768)//740, 데스크톱 1920(1200)

참고) 반응형을 위한 기본 섹션 레이아웃
- 레이아웃 최저 해상도 지원 320w (body에 min-width로 적용되어 있음)
- 컨텐츠 최소값 300w & 최대 400w까지 늘어날 수 있다. 
- 360w이하 해상도에서는 컨텐츠 좌우여백 10이어야만 320까지 지원 가능
- 460w이하 해상도에서는 컨텐츠가 늘어나(300 -> 400)고 좌우 여백 30고정
- 460w이상 해상도에서는 컨텐츠 최대 사이즈(400)로 고정후 좌우 여백이 늘어남

참고) 가변단계 정의 Nike	
- 640px 이하: 스마트폰	
- 768px~960px: 테블릿	
- 1024px~1420px: 기본	
- 1920px 이상: 큰화면


## 모션이미지 적용 및 IOS 저전력모드 대응
모션이미지로 작업된 비디오영상이 자동재생되지 않고 재생버튼이 노출된다.

- 초기 모션이미지 적용을 위해 lottie, gif, apng 등을 검토하였으나 최종적으로는 mp4를 이용해 모션이미지를 반복할 수 있도록 하였다.
- 앱별로 지원여부를 파악하였고 추가로 IOS 저전력모드에서는 동영상이 자동재생되지 않고 재생버튼이 노출되는 문제가 발견되었는데,
- 이는 재생환경에 따라 재생될 수 있도록 수동재생하고 그에따른 예외처리를 하여 해결하였다.
- 이때, 부드러운 동작을 위해 첫 프레임을 포스터로 적용하고 재생될 수 없는 환경에서는 완료된 모션이미지가 노출될 수 있도록 마지막 프레임을 적용하였다.

참고) 대안들
- lottie: 용량은 적지만 쓸수있는 이펙트에 한계가 있음 (간단한 모션o, 복잡한 모션x)
- gif: 화질이 좋지 않음(256컬러)
- apng: 화질은 좋으나 용량이 큼(비표준. IE10이상)
- mp4: 부드러운 영상. 앱(NativeApp Webview)에서 지원필요. 배터리저전력모드 별도 처리필요.



## 느린네트워크 환경에서 웹폰트로 지정된 텍스트가 늦게 노출됨
디자인된 한글 웹폰트가 늦게 적용되어 텍스트 노출이 지연된다.
- 웹폰트가 늦게 적용되는 원인들을 조사하고 하나씩 대응하며 테스트 진행.
- 웹폰트 다운로드 시점을 앞당기거나 경량화(361kb이지만 다른 폰트는 20bk내외)된 폰트사용, 브라우저별 폰트 렌더링 방식들을 대응하였지만 여전히 부드럽지 않은 렌더링
- 최종적으로는 이미지 폰트를 활용하여 개선. 이때 웹접근성을 지원하도록 한다. 

## BFF 서버 아키텍처 공유 및 커뮤니케이션
백엔드 API가 의도대로 동작하지 않아 문의를 하였는데,  초기 커뮤니케이션이 제대로 이루어지지 않았ㄱ다.
- 프론트서버 구성시 인증을 처리하는 별도 서버사이드를 구성한 상태였는데 커뮤니케이션 대상자와 개발환경에 대한 이해가 서로 다르다는 것을 깨달았다.
- BFF로 구성된 서버 아키텍처를 공유하며 개발환경을 공유하였고 이에 문제원인을 파악하였고 문제를 해결할 수 있었다.

## 데이터 패칭 상태 고민
사용자의 경험을 해치지 않고 데이터 요청중 상태를 표현해보자.
- 상황에 따라 풀뷰로딩 / 영역 스피너 로딩 / 스켈레톤 
- 특히 선택 가능 영역에 대한 press스타일을 적용하여 액션이 진행되었음을 인지할 수있도록 하였다. 

## 데이터 패칭 상태 고민

            [디자인 협업]
            - 현상: 쉐도우 + 이미지를 합쳐 화면에 노출하는데 미세한 차이가 있음.
            - 원인: 피그마 툴을 이용하여 디자인된 스타일을 적용하였는데, 그곳에서 생성된 같은 스타일의 이미지가 미세하게 달랐다.
            - 해결: 적용된 결과물(산출물)을 보며 의견을 나누고 해결안으로는 전체 디자인을 받음
            - 참고: 
            `,
            `
            [서비스 접근 에러]
            - 현상: 안드로이드 기기에서 가끔식 서비스 접근 에러발생.
            - 원인: 버티컬 웹뷰간 인증토큰 쿠키가 생성되는데, 이때 subDomain / mainDomain으로 각각 생성되어 키가 중복되는 쿠키가 두개 쓰임. 만료시 하나만 갱신되는데, 갱신되지 않은 토큰으로 서비스 요청하여 접근 에러발생.
            - 해결: 쿠키가 중복으로 생성되는 케이스가 subDomain / mainDomain 으로 각각 생성되는 이유로. mainDomain 으로만 맞춤.
            - 참고: ios는 웹뷰간 토큰 공유되지 않음. / rewrite는 쉽지 않음. 조건이 맞아야 함.
            `,
            `
            [storybook sass 로더 에러]
            - 현상: storybook 에서 sass-loader 가 동작하지 않음.
            - 원인: storybook 6에서 빌드툴(모듈 빌더/번들러)로 webpack4를 사용하는데 sass-loader 는 webpack4를 더이상 지원하지 않아 에러발생
            - 해결: 다행히도 storybook 빌드 옵션을 제공해주어 적용함. (npx sb init --builder webpack5)
            - 참고: https://storybook.js.org/blog/storybook-for-webpack-5/
            `,
            `
            [IOS 낮은 저 버전에서 레이아웃 깨짐]
            - 현상: QA하다가 발견. iOS 저버전(13.3) 이하에서만 발생되는 이슈로 특정영역 overflow 가 동작하지 않음.
            - 원인: iOS 13.3까지는 overflow 속성에 2개 값을 할당하는 형태가 지원되지 않음
            - 해결: overflow 속성에 2개 값을 할당 대신 각각 정의
            - 참고: https://caniuse.com/css-overflow
            `,
            `
            [페이지네이션 관련 offset 미적용 이슈]
            - 현상: 공통평가 목록 요청시 전체갯수와 목록갯수가 일치하지 않는 문제가 발견됨. 
            - 원인: 처음에는 API 이슈인듯 하였으나, 서버사이드 페이징구현을 인지 하지 못하고 맞지 않는 전달인자로 요청을 보냄. 이유는, 버티컬 API 들은 모두 클라이언트사이드에서 페이징구현이 되어 있는데, 처음 사용하는 공통 API 에서의 서버사이드 페이징 구현을 알아채지 못하고 그대로 적용함. 알파개발환경에서는 데이터가 적어서 미처 동작을 확인하지 못함. 
            - 해결: 임시대처로 임의 1000개 데이터를 호출하여 클라이언트 페이지네이션 기능을 적용하도록 함
            - 참고: API 문서를 제대로 읽어야한다..
            `,
            `
            [WAI-ARIA focus]
            - 현상: 웹접근성 테스트시 포커싱이 되지 않는 anchor 엘리먼트가 존재함.
            - 원인: 웹접근성이 지원되지 않는 조건에 href가 없는 a 엘리먼트인 것으로 확인. 추가적으로 웹접근성 포커싱이 미지원되는 엘리먼트가 있다는 것을 알게됨 ex) div
            - 해결: 다양한 엘리먼트를 테스트하여 키보드로 포커스를 받을 수 있는지 없는지 확인 후, 필요에따라 tabIndex 적용(포커스를 받지 않을 때 -1 / 포커스 받을 때 0 / 우선으로 포커스 받을 때 1)
            - 참고: 
            `,
            `
            [특정 페이지에서 개발한 sdk 스크립트 에러 발생]
            - 현상: 특정 페이지에서 공통 gnb영역을 그리는 sdk 스크립트 에러 발생. js 코드가 정상동작하지 않음.
            - 원인: 특정 페이지에서 native reduce가 재정의된 prototype.js 파일이 전역으로 로드되고 있는데, Prototype JavaScript framework (prototype.js) 을 사용하면 Array를 편리하게 사용할 수 있도록 내부의 Enumerable객체와 extend 하게되어 native 객체가 변경된다.
            - 해결: protorype.js 보다 sdk를 먼저 로드하여 그리도록 하여 스코프에 영향을 받지 않도록 하였음.
            - 참고: 
            `,
            `
            [nextjs SSR / CSR]
            - 현상: 사용자 정의 웹팩에 플러그인 적용시 2번 적용되는 이슈
            - 원인: webpack함수는 서버에 대해 한 번, 클라이언트에 대해 한 번, 두 번 실행되기 때문
            - 해결: isServer 아규먼트를 통해 서버 측 컴파일 및 클라이언트 측 컴파일 구분하여 적용 (서버? 클라?)
            - 참고: https://nextjs.org/docs/api-reference/next.config.js/custom-webpack-config
            `,
            `
            [nextjs 환경변수 설정]
            - 현상: 실행환경에 따라 환경변수 기본 파일 설정됨. 
            (.env.[development | production]) 클라이언트/서버 사이드에서 환경변수를 구분할 수 있도록 구분자를 제공(NEXT_PUBLIC_)하는데, 
            NEXT_PUBLIC_ 구분자 없이도 환경변수 사용이 가능한 경우가 있음.
            - 원인: 다양한 환경을 구분하기 위해 dotEnv를 통해 env 를 주입하는 경우, 브라우저에 환경변수를 노출하는 NEXT_PUBLIC_ 설정이 무시됨.
            - 해결: dotEnv를 통한 환경변수들을 구분해두고 nextjs 환경에서 기본으로 로드되는 환경변수 저장 파일로 변경함. (항상 기본 설정을 재정의되는 파일 .env.local 로 copy)
            - 참고: https://nextjs.org/docs/basic-features/environment-variables
            `,
            `
            [safari 100vh가 정상동작하지 않음]
            - 현상: 반응형 웹을 구축하던 도중, 100vh가 PC 웹에서는 제대로 작용하나 모바일 웹에서 제대로 적용되지 않는 문제. 모바일에서는 상단에 위치한 url바와 하단에 있는 네이게이션바로 인해서 100vh를 설정하더라도 아래 혹은 윗 부분이 잘리는 현상이 발생한다. (상하단에 위치한 바 아래로 화면이 감춰진다.)
            - 원인: height: 100vh 를 Chrome에서 사용하는 계산 방식으로 인해 발생. vh는 viewport height에 해당하는 단위로 해당 브라우저의 높이에 따라서 상대적으로 적용되는 단위
            - 해결: ? 자바스크립트 계산
            `,
            `
            [모바일 웹뷰대응 + 전체 해상도]
            - 현상: 디바이스 별 기준 해상도를 각각 두고 디자인 -> 반응형으로 적용 필요한데 320w 740w 반응형으로 유연하게 동작하지 못함 + 상단 이미지 배치로 모바일 환경에서 예상하지 못한 가로 스크롤 발생
            - 원인: 좌우 여백을 디자인된 값으로만 고정하여 화면이 늘어나도 컨텐츠가 가운데 정렬되지 못하는 문제 발생 + 오버 플로우 값을 조정한다.
            - 해결: 모바일 우선 반응형 웹 디자인한다. 브레이크 포인트(가로사이즈 기준이 되는 특정 해상도 정하기 320w 740w)
            `,
            `
            [히스토리관리 back]
            - 현상: 아래와 같은 케이스들에 활용할 수 있습니다.
              - 이전 페이지인 결제 페이지가 아닌 홈으로 이동 되어야함
              - 정보를 저장할지 여부를 확인해야함 (브라우저 history back)
              - 종료 안내 모달을 노출해야함 (webview close)
              - 바텀시트가 닫혀야함
              - 백 제스쳐를 비활성화되어야 하는 페이지(뒤로가기 금지 - 결제페이지 등)
            - 원인: 
            - 해결: 
            `,
            `
            [단순반응형 이외]
            - 현상: 최소컨텐츠 사이즈와 최대컨텐츠 사이즈 사이에서 유연하게 반응할 수 있도록
            - 원인: 
            - 해결: 네이티브 앱처럼 느껴질 정도로 유려한 UX를 제공하기 위해 웹뷰 위에서의 어플리케이션을 최적화한다.
            웹페이지가 모든 기기 및 해상도에서 디자이너가 의도한 디자인을 그대로 전달하도록 세심히 구현한다.
            빠른 가설–실험–교훈 반영의 주기를 유지하기 위해 비효율을 없애고 컴포넌트화, 자동화 할 수 있는 부분을 찾아 반영한다.
            `,
            `
            [TDD]
            프론트엔드 개발자는 백엔드 개발자와의 원활한 소통을 위해 API와 그 문서등을 이용합니다. 커뮤니케이션에 필요한 API의 잦은 변경으로, 요청과 응답 데이터에 의존하고 있는 화면들에 얘기치 못한 문제가 발생한 적이 있습니다. 새로운 시스템을 구축하는 단계에서 프론트엔드 팀은 기능개발에 집중하고 있었는데 이미 구현된 기능의 API 변경에 대해 대응하지 못하여, 화면 렌더링이 제대로 되지 않는 문제였습니다. 그중 가장 큰 문제는, 어떤 화면에 문제가 발생하고 있는지 조차 인지되지 못하고 있던 점 이었습니다. API 변경으로 인해 발생하는 화면단의 사이드 이펙트를 최소화하기 위하여 저는 TDD개발을 제안하였습니다.
            TDD는 테스트를 주도로 하여 기능을 개발하는 것으로, 기능을 추가하기에 앞서 API와의 통신 및 응답을 확인한 이후 화면 개발을 하자는 취지였습니다. 처음에는 테스트코드를 작성하는데 많은 비용이 들었지만, 잦은 API변경을 대응하는데에는 효과적이었습니다. 작성해둔 테스트코드를 통해 API가 변경되거나 통신이 되지 않는 경우에 대하여 문제가 바로 인지되었기 때문에 전 보다는 개선사항에 대한 문제의 범위가 좀 더 명확해지기도 하였습니다. 추가적인 이점으로, 서버와의 통신 자체에 문제가 발생하는 경우 서버 응답 데이터에 의존하고 있는 화면개발이 중단되는 문제가 있었는데 이는 TDD시에 미리 작성해둔 모의객체(mock)를 바라보게 함으로써 관련된 이슈도 사전에 방지 할 수 있게 되었습니다.
            프론트와 백엔드를 동시에 개발하며 API의 변경이 불가피한 경우, 대처하는 방안에 대해 고민하며 일정내 개발을 완료하는데 많은 도움이 되었습니다.